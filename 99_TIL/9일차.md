**항해 9일차**
오늘도 알고리즘을 풀었다.

오늘 푼 문제들 중에서 가장 인상깊었던 문제를

_** 간략하게 보자면**_
![](https://velog.velcdn.com/images/ehddjs113/post/7d373a0f-ef75-458f-a7a9-c10c69cd7522/image.png)

이런 문제이다. 문제에 **핵심 포인트**만 간추린다면

> 0. 뽑을 수 있는 개수를 정해놓음 = nums.length / 2

1. 중복 제거 => 단, 그렇게 되면 배열의 길이가 줄어듦.(중복이 없을 경우 줄어들지 않을 수도 있긴 함)
2. 중복이 제거된 배열에서 num.length/2 만큼 뽑음. => 결국에는 이게 result이긴한데
3. 생각해봐야 할 경우: 한 종류만 무더기로 있는 경우 [3,3,3,3,3,3]
4. [3]만 남는데 전체의 길이는 6이었으니까 6/2 =3
5. 그래서 결국 [3] 에서 3번을 뽑아야 함. 근데 얘의 결과가 1을 return 하도록 만들어야 함.

### 해결한 내용

> 1. 입력 배열 nums의 길이를 2로 나누고, 결과값을 count 변수에 저장한다.
> 2. nums 배열의 요소들로부터 새로운 Set 객체를 생성한다. Set은 고유한 값을 갖는 집합을 나타내므로, 이 작업은 원래 배열에서 중복된 요소를 제거하는 효과가 있다.
> 3. 전개 연산자([...newSet])를 사용하여 Set 객체를 다시 배열로 변환한다. 이제 원래 배열에서만 고유한 요소만을 포함하는 배열이 만들어진다.
> 4. filter 메서드가 이 배열에 적용되며, 콜백 함수가 true를 반환하는 요소만을 포함하는 새로운 배열이 반환된다. 이 경우, 콜백 함수는 현재 처리 중인 요소를 나타내는 ele 인자와 함께 인덱스를 나타내는 idx 인자를 받는다.
> 5. filter 메서드에 적용된 콜백 함수는 다음과 같습니다: idx가 count보다 작은 요소만을 포함하는 새로운 배열이 반환된다.

```js
function solution(nums) {
  let count = nums.length / 2;
  let newSet = new Set(nums);
  return [...newSet].filter((ele, idx) => idx < count).length;
}
```

### 알게 된 점

> 알고리즘의 내용이 길어 너무 어려워 보였다. 하지만 이러한 복잡한 내용들이더라도 메소드를 잘 사용하면 간단하게 풀 수 있다라는 것을 다시 한 번 알게 되었고, 알고리즘을 풀 때 문제 요구 사항과 주요 핵심들을 잘 찾아가면 문제를 풀어야 겠다. 🔥
